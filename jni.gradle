import org.gradle.internal.os.OperatingSystem

def generatedJNIHeaderLoc = "${buildDir}/jniinclude"

/**
 * Generates the JNI headers
 */
task jniHeaders {
    def outputFolder = file(generatedJNIHeaderLoc)
    inputs.files sourceSets.main.output
    outputs.file outputFolder
    doLast {
        outputFolder.mkdirs()
        exec {
            executable org.gradle.internal.jvm.Jvm.current().getExecutable('javah')
            args '-d', outputFolder
            args '-classpath', sourceSets.main.output.classesDir
            jniDefinitionClasses.each {
              args it
            }
        }
    }
}

ext.getJniSymbols = {
   def symbolsList = []

    jniHeaders.outputs.files.each {
        FileTree tree = fileTree(dir: it)
        tree.each { File file ->
            file.eachLine { line ->
                if (line.trim()) {
                    if (line.startsWith("JNIEXPORT ") && line.contains('JNICALL')) {
                        def (p1, p2) = line.split('JNICALL').collect { it.trim() }
                        // p2 is our JNI call
                        symbolsList << p2
                    }
                }
            }
        }
    }

    return symbolsList
}

// This creates a lambda that the main build.gradle can access, which sets up the JNI includes for the
// target build platform. This lambda is exposed as a property in the main build.gradle.
ext.setupJniCompile = { binaries, configs ->
    def platformSpecificIncludeFlag = { loc, cppCompiler ->
        if (OperatingSystem.current().isWindows()) {
            cppCompiler.args "/I$loc"
        } else {
            cppCompiler.args '-I', loc
        }
    }
    binaries.all { binary ->
        if (binary instanceof NativeBinarySpec) {
        def isArm = configs.findAll { (binary.targetPlatform.architecture.name == it.architecture
                                       && binary.targetPlatform.operatingSystem.name == it.operatingSystem
                                       && it.crossCompile) }.size() > 0
        tasks.withType(CppCompile) {
            if (isArm) {
                cppCompiler.args '-I', file("${rootDir}/src/arm-linux-jni").absolutePath
                cppCompiler.args '-I', file("${rootDir}/src/arm-linux-jni/linux").absolutePath
            } else {
                def jdkLocation = org.gradle.internal.jvm.Jvm.current().javaHome
                platformSpecificIncludeFlag("${jdkLocation}/include", cppCompiler)

                if (targetPlatform.operatingSystem.macOsX) {
                    platformSpecificIncludeFlag("${jdkLocation}/include/darwin", cppCompiler)
                } else if (targetPlatform.operatingSystem.linux) {
                    platformSpecificIncludeFlag("${jdkLocation}/include/linux", cppCompiler)
                } else if (targetPlatform.operatingSystem.windows) {
                    platformSpecificIncludeFlag("${jdkLocation}/include/win32", cppCompiler)
                } else if (targetPlatform.operatingSystem.freeBSD) {
                    platformSpecificIncludeFlag("${jdkLocation}/include/freebsd", cppCompiler)
                } else if (file("$jdkLocation/include/darwin").exists()) {
                    // TODO: As of Gradle 2.8, targetPlatform.operatingSystem.macOsX returns false
                    // on El Capitan. We therefore manually test for the darwin folder and include it
                    // if it exists
                    platformSpecificIncludeFlag("${jdkLocation}/include/darwin", cppCompiler)
                }
            }

            jniHeaders.outputs.files.each { file ->
                if (isArm) {
                    cppCompiler.args '-I', file.getPath()
                } else {
                    platformSpecificIncludeFlag(file.getPath(), cppCompiler)
                }
            }

            dependsOn jniHeaders
        }
    }
    }
}